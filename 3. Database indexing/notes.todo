Cómo crear una tabla con 1M rows?:

  CREATE TABLE temp (t int);
  INSERT INTO TEMP (t) SELECT RANDOM() * 100 FROM generate_series(0, 1000000);

Qué es un índice?:
  Es una estructura de datos que creamos sobre nuestras tablas y que intenta analizar y resumir
  la tabla para poder crear shortcuts. Se puede hacer una analogía con los labels que tienen
  algunos libros para indicarnos que estamos en cierto apartado.

  - EXPLAIN ANALYZE para ver cuánto se demora una consulta y qué hace internamente.
  - cuando buscamos por una expresión y no por un valor, e.g:

    SELECT name, salary FROM employees WHERE name LIKE '%esteban%'

    no se pueden aplicar los indexes que tenemos sobre las columnas, por lo que el motor de DB
    haría un full parallel sequential scan.

Explain explained:
  Este comando es una estimación, si queremos obtener información de data real tenemos que usar
  ANALYZE.

  - cost: consta de 2 números, el primero es lo que se tarda el motor en obtener la primera page,
    este número puede crecer en caso de que hagamos muchas operaciones antes de obtener la
    información (aggregation functions, por ejemplo). El segundo número es la estimación de cuánto
    cree el motor que va a tardar.
  - rows: una estimación de cuántas rows va a hacer fetch para esta consulta.
  - width: la suma de bytes para todas las columns.

Index Scan vs Index Only Scan:

  - Index Scan: cuando tenemos un index en una tabla pero por la consulta que estamos haciendo
    tenemos que volver a consultar a la tabla por más data que no tenía el index.
  - Index Only Scan: es cuando no tenemos que volver a la tabla a hacer fetch de más data, son
    las consultas ideales.
  - Podemos almacenar más data en un index (no va a ser usado para optimización o para búsquedas
    pero sí será fetched) de la siguiente manera

    CREATE INDEX id_idx ON stude  nts(id) INCLUDE (name);

    Esto se llama non-key indexes.

  - Tenemos que tener cuidado de no crear indexes demasiado pesados, estos podrían hacer las
    queries más pesadas.

key vs non-key indexes:

  - non-key indexes: son indexes que nos permiten incluir información en el index que no será usada
    para búsquedas pero sí estará incluida, por lo que podremos hacer un index only scan.
  - vacuum (verbose) table_name; esto nos dirá si tenemos algún error en la tabla o debemos remover
    algunas filas o columnas.
  - composite index: es un indeex que está compuesto de varias columnas y será más eficiente
    para queries que usen estas columnas. Cuando usamos un composite index, Postgres solamente
    puede acceder a la columna que está de lado izquierdo.
